/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../src/foxlisp-web.js":
/*!********************************!*\
  !*** ../../src/foxlisp-web.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("___process_args = []\n\n__webpack_require__(/*! ./lisp */ \"../../src/lisp.js\")\n\nlet load_file = (filePath) => {\n\t\n\treturn fetch(filePath)\n\t \t\n\t\t  .then(response => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn \"(println 'file-not-found \\\"\" + filePath + \"\\\")\"\n\t\t\t}\n\t\t\treturn response.text()\n\t\t\t\n\t\t  })\n\t\t  \n}\n\nfunction WriteCodeToLog(code){\n\treturn;\n}\nwriteCodetoLog = WriteCodeToLog\nloadFileAsync = load_file\n\nconsole.log(\"foxlisp JS loaded!\")\n\n\n//# sourceURL=webpack:///../../src/foxlisp-web.js?");

/***/ }),

/***/ "../../src/lisp.js":
/*!*************************!*\
  !*** ../../src/lisp.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parser = __webpack_require__(/*! ./lispy_parser */ \"../../src/lispy_parser.js\")\nconst lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\nfunction sym(x, jsname){\n    return lisp.sym(x, jsname)\n}\n\nfunction issym(x){\n\t return x && x.type == \"symbol\";\n}\n\ndoEval = function (code){\n\t eval?.(code)\n}\n\n___sym = lisp.lisp.symbols\n__quotes = []\nconst quotes_lookup = new Map()\nfunction _getQuote(id) {\n    return __quotes[id]\n}\ngetQuote = _getQuote\nfunction setQuote(newQuote){\n\t \n\t let existing = quotes_lookup.get(newQuote)\n\t \n\t if(existing) {\n\t\t  return existing\n\t }\n    let id = __quotes.length;\n    __quotes.length += 1\n    __quotes[id] = newQuote\n\t quotes_lookup.set(newQuote, id)\n    return id\n}\n\nlookupsym = lisp.getsym\ncar = (x) => x && x[0]\ncdr = (x) => x && x.slice(1)\nop_add = (x, y) => x + y\nop_sub = (x, y) => x - y\nop_div = (x, y) => x / y\nop_mul = (x, y) => x * y\nop_leftshift = (x, y) => x << y;\nop_rightshift = (x, y) => x >> y;\nop_xor = (x, y) => x ^ y;\nop_or = (x,y) => x|y;\nop_and = (x,y) => x&y\n\nmod = (x, y) => x % y\nnot = (x) => !x\nlen = (x) => (x && x.length) || 0\nlist = (...x) => x\n__undefined = undefined\n\neq = (a, b) => a === b;\nslice = (a, n) => a && (a.length <= n ? null : a.slice(n));\n_raise = (err) => {throw err;}\n\nusplice = (x) => ({type: \"unsplice\", value: x})\n\nloadfile = (x, loadcontext) => ({type: \"load\", value: x, loadcontext: loadcontext})\n\nmacroLookup = new Map();\n\nismacro = (x) => macroLookup.has(x)\n\nulist = (...x) => {\n\t let out = []\n\t for (let elem of x){\n\t\t  if(elem == undefined){\n\t\t\t\tthrow new Error(\"content is undefined\" + x);\n\t\t  }\n\t\t  if(typeof(elem) == \"object\" && elem.type == \"unsplice\"){\n\t\t\t\tfor (let elem2 of elem.value){\n\t\t\t\t\t out.push(elem2);\n\t\t\t\t}\n\t\t\t\t\n\t\t  }else{\n\t\t\t\tout.push(elem);\n\t\t  }\n\t }\n\t \n\t return out\n}\n\nfunction escapeString(x){\n\t return x.replace(/\"/g, '\"\"').replace(/\\n/g, '\\\\n')\n}\n\ngetsym = (s) => sym(s, null)\n\nfunction println_impl(obj){\n\t if(Array.isArray(obj) || obj instanceof Float32Array){\n\t\t  \n\t\t  let strOut = \"\"\n\t\t  let first = true\n\t\t  \n\t\t  strOut += \"(\"\n\t\t  \n\t\t  for(let elem of obj){\n\t\t\t\tif(!first){\n\t\t\t\t\t strOut = strOut + \" \";\n\t\t\t\t}else{\n\t\t\t\t\t first = false;\n\t\t\t\t\t if(elem == quoteSym){\n\t\t\t\t\t\t  return \"'\" + println_impl(obj[1]);\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tstrOut += println_impl(elem)\n\t\t\t\t\n\t\t  }\n\t\t  \n\t\t  strOut += \")\"\n\t\t  return strOut;\n\t }else{\n\t\t  if(obj === null){\n\t\t\t\treturn \"null\";\n\t\t  }\n\t\t  if(obj === undefined){\n\t\t\t\treturn \"undefined\"\n\t\t  }\n\t\t  \n\t\t  if(obj.type === \"symbol\"){\n\t\t\t\treturn obj.value;\n\t\t  }\n\t\t  if(typeof obj === \"string\") {\n\t\t\t\treturn `\"${obj}\"`\n\t\t  }\n\t\t  return obj.toString()\n\t }\n}\n\nprintln = (...a) => {\n\t let combined = \"\"\n\t let first = true\n\t for(let elem of a){\n\t\t  if(!first){\n\t\t\t\tcombined = combined + \" \"\n\t\t  }else{\n\t\t\t\tfirst = false\n\t\t  }\n\t\t  combined = combined + println_impl(elem)\n\t }\n\t // print without newline:\n\t console.log(combined)\n\t return a[0]\n}\n\n__valueToString = (a) => println_impl(a);\n\nnth = (a, n) => a && (n >= a.length ? null : a[n])\nsetnth = (a, n, v) => a[n] = v\ngetnth = (a, n) => a[n]\nmakemap_ = () => ({type: \"lisp-object\"})\nput = (obj, name, value) =>  obj[name.jsname ? name.jsname : name] = value\nget = (obj, name) => obj[name.jsname ? name.jsname : name]\ncharcode = (a) => a.charCodeAt(0)\nstrfromchar = (...a) => String.fromCharCode(...a)\nreverse = (a) => a.slice().reverse()\n_op_gte = (a,b) => a >= b\n_op_lte = (a,b) => b >= a\n_op_lt = (a,b) => a < b\n_op_gt = (a,b) => a > b\nconcat = (...lst)=> len(lst) == 0 ? [] : lst[0].concat(...lst.slice(1))\n__makesym = (a) => sym(a)\n_typeof = (a) => typeof a\n\n\nconst loopSym = sym(\"loop\");\nconst notSym = sym(\"not\");\nconst setSym = sym(\"set\");\nconst letSym = sym(\"let\");\nconst constSym = sym(\"const\");\nconst prognSym = sym(\"progn\");\nconst ifSym = sym(\"if\");\nconst lambdaSym = sym(\"_lambda\");\nconst defMacroSym = sym(\"setmacro\");\nconst orSym = sym(\"or\");\nconst andSym = sym(\"and\");\nconst blockSym = sym(\"_block\");\nconst returnFromSym = sym(\"return-from\")\nconst jsSym = sym(\"%js\")\nconst quoteSym = lisp.quote_sym;\nconst keywordSym = lisp.keyword_sym;\nconst quasiQuoteSym = lisp.quasiquote_sym;\nconst quasiUnQuoteSym = lisp.quasiunquote_sym;\nconst quasiUnQuoteSpliceSym = lisp.quasiunquotesplice_sym;\nconst restSym = sym(\"&rest\")\nconst declareSym = sym(\"declare\")\nconst defvarSym = sym(\"defvar\");\nconst handleErrorsSym = sym(\"handle-errors\")\nconst loop_sym = sym(\"loop\")\nconst withSym = sym(\"with\")\n\nfunction quotedJs(code){\n\t if(Array.isArray(code)){\n\t\t  const innerCode = code.map(elem => quotedJs(elem)).join(',');\n\t\t  return `[${innerCode}]`\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  \n\t\t  return `___sym[${code.index}]`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\t \n\t return code.toString();\n\n}\n\nfunction unscope(code){\n\t if(isScope(code)){\n\t\t  return `(()=>{var tmp_unscope; ${code.replaceAll(value_marker, \"tmp_unscope =\")}; return tmp_unscope})()`\n\t }\n\t return code\n}\n\nfunction unquoteToJs(code){\n\t if(code == null){\n\t\t  return \"null\"\n\t }\n\t if(Array.isArray(code)){\n\t\t  if(code[0] == quasiQuoteSym){\n\t\t\t\t\n\t\t\t\treturn quotedJs(code) \n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSpliceSym){\n\t\t\t\t\n\t\t\t\treturn `usplice(${unscope(lispCompile(code[1]))})`;\n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSym){\n\t\t\t\treturn unscope(lispCompile(code[1]))\n\t\t  }\n\t\t  const innerCode = code.map(elem => unquoteToJs(elem)).join(',');\n\t\t  return `ulist(${innerCode})`;\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  return `___sym[${code.index}]`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\n\t \n\t \n\t return code.toString();\n}\n\nfunction scope(items){\n\t for(let i = 0; i < items.length; i++){\n\t\t  if(i == items.length -1){\n\t\t\t\tif(isScope(items[i])){\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t}else{\n\t\t\t\t\t items[i] = value_marker + \" \" + items[i]\n\t\t\t\t}\n\t\t  }else{\n\t\t\t\tif(isScope(items[i]))\n\t\t\t\t\t items[i] = items[i].replaceAll(value_marker,\"\")\n\t\t  }\n\t\t  \n        \n\t }\n\t let a =  items.map(i => i + \";\").join(\"\")\n\t return a\n}\n\nconst value_marker = \"__>>VALUEMARKER<<__\"\nfunction isScope(code){\n\t return typeof(code) == 'string' && code.includes(value_marker)\n}\n\nfunction lispCompileLet(variables, body, isConst){\n\t const kw = isConst ? \"const\" : \"let\"\n\t let brackets = 0\n\t let usedNames = {}\n\t const varCode = variables.map(updateExpr => {\n\t\t  if(updateExpr.length != 2){\n\t\t\t\tthrow new Error(\"The expression (xyz) is malformed.\" + println_impl(updateExpr));\n\t\t  }\n        const [left, right] = updateExpr;\n\t\t  let r = lispCompile2(right)\n\t\t  if(isScope(r)){\n\t\t\t\tcode = `${kw} ${left.jsname};${r.replaceAll(value_marker, left.jsname + \"=\")}`\n\t\t  }else{\n\t\t\t\tcode = `${kw} ${left.jsname} = ${r}`\n\t\t  }\n\t\t  if(brackets == 0 || left.jsname in usedNames){\n\t\t\t\tbrackets += 1\n\t\t\t\tusedNames = {}\n\t\t\t\tcode = \"{\" + code;\n\t\t  }\n\t\t  usedNames[left.jsname] = true\n        return code;\n    });\n    if(body.length == 0){\n\t\t  body = [[]]\n\t }\n\t if(body.length == 1 && variables.length == 0){\n\t\t  return `${lispCompile(body[0])}`\n\t }\n\t result = scope(varCode.concat(body.map(x => lispCompile(x))))\n\t for(let i = 0; i < brackets; i++){\n\t\t  result = result + \"}\";\n\t }\n\t return result;\n}\nlmbmark = (id, f) => {\n\t f.assoc_id = id;\n\t return f;\n}\n\nlet associd = 0;\nlet assoc = {}\n///\\/\\*lmb#(\\d+)\\*\\//\nconst markRegex = /\\/\\*lmb#(\\d+)\\*\\/\\(/g;\nlet codeStack = []\n\nfunction lispCompile(code, assignto){\n\t const result = lispCompile2(code);\n\n\t if(isScope(result) && assignto){\n\t\t  const fin = result.replace(value_marker, assignto);\n\t\t  return fin\n\t }\n\n\t if(assignto){\n        const r = assignto + \" \" + result;\n\t\treturn r\n\t }\n\t \n\t return result;\n\n}\n\nfunction lispCompile2(code) {\n\t \n\t try{\n\t\t  codeStack.push(code);\n\t\t  if(typeof(code) == \"number\"){\n\t\t\t\treturn code\n\t\t  }\n\t\t  if(typeof(code) == \"string\"){\n\t\t\t\tcode = code.replaceAll(\"\\\"\", \"\\\\\\\"\");\n\t\t\t\tcode = code.replaceAll(\"\\n\", \"\\\\n\");\n\t\t\t\treturn `\\\"${code}\\\"`;\n\t\t  }\n\t\t  if(code == undefined){\n\t\t\t\treturn \"undefined\"\n\t\t  }\n\t\t  if (code.type == \"symbol\"){\n\t\t\t\treturn code.jsname\n\t\t  }\n\t\t  if(code.length == 0) {\n\t\t\t\treturn \"null\"\n\t\t  }\n\n\t\t  const [operator, ...operands] = code;\n\t\t  switch (operator) {\n\t\t  case loopSym:\n\t\t\t\tconst [condition, ...update] = operands;\n\t\t\t\t\n\t\t\t\tlet updateCode = lispCompileLet([], update);\n\t\t\t\tlet conditionCode = lispCompile(condition);\n\t\t\t\tif(!isScope(updateCode)){\n\t\t\t\t\t updateCode = value_marker + updateCode\n\t\t\t\t}\n\t\t\t\tif(isScope(conditionCode)){\n\t\t\t\t\t conditionCode = conditionCode.replaceAll(value_marker, \"condition =\")\n\t\t\t\t\t return `while(true) { var condition; ${conditionCode}; if(!condition){break;} ${updateCode}}`;\n\t\t\t\t}\n\t\t\t\treturn `while (${conditionCode}) {  ${updateCode}; }`;\n\t\t  case jsSym:\n\t\t\t\t{\n\t\t\t\t\t let outstr = \"\";\n\t\t\t\t\t for (let x of operands) {\n\t\t\t\t\t\t  if (typeof(x) == \"string\") {\n\t\t\t\t\t\t\t\toutstr += x;\n\t\t\t\t\t\t  }else{\n\t\t\t\t\t\t\t\toutstr += lispCompile(x)\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\t\t\t\t\t return outstr;\n\t\t\t\t\t \n\t\t\t\t}\n\t \t\t\t\n\t\t  case blockSym:{\n\t\t\t\tconst [sym, ...body] = operands;\n\t\t\t\tlet bodyCode = lispCompile(body[0])\n\t\t\t\t\n\t\t\t\tif(!isScope(bodyCode)){\n\t\t\t\t\t \n\t\t\t\t\t bodyCode = value_marker + \" \" + bodyCode\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn `const ${sym.jsname} = {};try{${bodyCode}}catch(ex){if(ex.id === ${sym.jsname}){${value_marker} ex.value;}else{_raise(ex);}}`\n\t\t  }\n\t\t  case returnFromSym:{\n\t\t\t\tconst [sym, value] = operands;\n\t\t\t\tlet valuef = lispCompile(value);\n\t\t\t\tlet pre = \"\"\n\t\t\t\tif(isScope(valuef)){\n\t\t\t\t\t pre = \"var tmpValue;\" + valuef.replaceAll(value_marker,\"tmpValue =\") + \";\";\n\t\t\t\t\t valuef = \"tmpValue\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn `${pre} _raise({id:${sym.jsname}, value:${valuef}, type: \"return-from\" })`;\n\t\t  }\n\t\t  case lambdaSym:\n\t\t\t\t{\n\n\t\t\t\t\t const [args, ...body] = operands;\n\t\t\t\t\t // find invalid args    \n\t\t\t\t\t for(let arg of args){\n\t\t\t\t\t\t  if(arg.type != \"symbol\"){\n\t\t\t\t\t\t\t\tthrow new Error(\"Invalid argument in lambda: \" + arg + \" in \" + println_impl(code));\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\n\t\t\t\t\t const restIndex = args.indexOf(restSym)\n\t\t\t\t\t let argstr = args.map(arg => arg.jsname).join(\",\")\n\t\t\t\t\t if(restIndex != -1){\n\t\t\t\t\t\t  argstr = args.slice(0, restIndex).map(arg => arg.jsname).concat([\"...\" + args[restIndex + 1].jsname]).join(\",\");\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t assoc[associd] = operands\n\t\t\t\t\t \n\n\t\t\t\t\t let bodyCode = lispCompileLet([], body)\n\t\t\t\t\t if(isScope(bodyCode)){\n\t\t\t\t\t\t  bodyCode = \"{ var lambdaResult;\"+ bodyCode.replaceAll(value_marker, \"lambdaResult=\") + \"return lambdaResult}\"\n\t\t\t\t\t }\n\t\t\t\t\t let lmb = `(${argstr}) => ${bodyCode}`;\n\t\t\t\t\t \n\t\t\t\t\t return lmb\n\t\t\t\t}\n\t\t  case prognSym:\n\t\t\t\treturn lispCompileLet([], operands)\n\t\t  case keywordSym:\n\t\t  case quoteSym:\n\t\t\t\t{\n\t\t\t\t\t const [quoted] = operands\n\t\t\t\t\t if(issym(quoted)){\n\t\t\t\t\t\tif(quoted.index > -1){\n\t\t\t\t\t\t\treturn `___sym[${quoted.index}]`\n\t\t\t\t\t\t}\n\t\t\t\t\t\t  return `getsym(\\\"${quoted.value}\\\")/*3*/`\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t const id = setQuote(quoted)\n\t\t\t\t\t return `__quotes[${id}]`\n\t\t\t\t}\n\t\t  case quasiQuoteSym:\n\t\t\t\t{\n\t\t\t\t\t const [quoted] = operands\n\t\t\t\t\t const code = unquoteToJs(quoted)\n\t\t\t\t\t return code;\n\t\t\t\t}\n\t\t  case defvarSym:\n\t\t\t\t{\n\t\t\t\t\t \n\t\t\t\t\t const [sym, code] = operands;\n\t\t\t\t\t let valueCode = lispCompile(code);\n\t\t\t\t\t if (typeof(valueCode) == \"string\"){\n\t\t\t\t\t\t  valueCode = valueCode.replace(markRegex, 'lmbmark($1,');\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t let code2 = `${sym.jsname} = ${valueCode}`;\n\t\t\t\t\t if(isScope(valueCode)){\n\t\t\t\t\t\t  code2 = `${sym.jsname} = null;${valueCode.replaceAll(value_marker, sym.jsname + \"=\")}`\n\t\t\t\t\t }\n\n\t\t\t\t\t //console.log(code2)\n\t\t\t\t\t let result = doEval(code2);\n\t\t\t\t\t if(typeof(result) == \"function\" && result.assoc_id){\n\t\t\t\t\t\t  result.lispname = sym\n\t\t\t\t\t }\n\t\t\t\t\t return `/*DEFVAR*/${sym.jsname}`\n\t\t\t\t}\n\t\t  case defMacroSym:\n\t\t\t\t{\n\t\t\t\t\t const [sym, code] = operands;\n\t\t\t\t\t const macroCode = lispCompile(code)\n\t\t\t\t\t \n\t\t\t\t\t macroValue = eval(macroCode);\n\t\t\t\t\t \n\t\t\t\t\t macroLookup.set(sym, macroValue)\n\t\t\t\t\t \n\t\t\t\t\t return \"1\"\n\t\t\t\t}\n\t\t  case setSym: {\n\t\t\t\tconst [variable, value] = operands;\n\t\t\t\tlet result = lispCompile(value)\n\t\t\t\tlet leftHand = variable.jsname\n\t\t\t\tif(Array.isArray(variable)){\n\t\t\t\t\t leftHand = lispCompile(variable)\n\t\t\t\t\t if(isScope(leftHand)){\n\t\t\t\t\t\t  throw \"left hand of set cannot be a scope\"\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isScope(result)){\n\t\t\t\t\t result = result.replaceAll(value_marker, value_marker + leftHand + \"=\")\n\t\t\t\t\t \n\t\t\t\t}else{\n\t\t\t\t\t result = leftHand + \"=\" + result;\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t  }\n\t\t  case letSym: {\n\t\t\t\tconst [variables, ...body] = operands\n\t\t\t\treturn lispCompileLet(variables, body)\n\t\t  }\n\t\t  case constSym: {\n\t\t\t\tconst [variables, ...body] = operands\n\t\t\t\treturn lispCompileLet(variables, body, true)\n\t\t  }\n\t\t  case ifSym:\n\t\t\t\t{\n\t\t\t\t\t const [condition, thenClause, elseClause] = operands;\n\n\t\t\t\t\t let conditionCode = lispCompile(condition);\n\t\t\t\t\t let thenCode = lispCompile(thenClause);\n\t\t\t\t\t let elseCode = elseClause == null ? \"null\" : lispCompile(elseClause);\n\t\t\t\t\t \n\t\t\t\t\t if(thenCode === null || thenCode === \"\"){\n\t\t\t\t\t\t  thenCode = \"null\"\n\t\t\t\t\t }\n\t\t\t\t\t if(elseCode === null || elseCode === \"\"){\n\t\t\t\t\t\t  elseCode = \"null\"\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(conditionCode) && !isScope(thenCode) && !isScope(elseCode)){\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  return `(${conditionCode} ? ${thenCode} : ${elseCode})`\n\t\t\t\t\t }\n\t\t\t\t\t let js = \"\"\n\t\t\t\t\t let isConditionScope = false;\n\t\t\t\t\t if(isScope(conditionCode)){\n\t\t\t\t\t\t  js = \"{var check; \" + conditionCode.replaceAll(value_marker, \"check = \");\n\t\t\t\t\t\t  conditionCode = \"check\"\n\t\t\t\t\t\t  isConditionScope = true\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(elseCode)){\n\t\t\t\t\t\t  elseCode = value_marker + \" \" + elseCode;\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(thenCode)){\n\t\t\t\t\t\t  thenCode = value_marker + \" \" + thenCode;\n\t\t\t\t\t }\n\t\t\t\t\t js = js + `if(${conditionCode}){${thenCode}}else{${elseCode}${isConditionScope ? \"}\" : \"\"}} `\n\n\t\t\t\t\t \n\t\t\t\t\t return js;\n\t\t\t\t}\n\t\t  case handleErrorsSym:\n\t\t\t\t{\n\t\t\t\t\t \n\t\t\t\t\t const [body, handler] = operands;\n\n\t\t\t\t\t const [varSym, handlerBody] = handler;\n\t\t\t\t\t const bodyCode = lispCompile(body);\n\t\t\t\t\t const handlerBodyCode = lispCompile(handlerBody);\n\t\t\t\t\t return `try{${isScope(bodyCode) ? bodyCode : value_marker + \" \" + bodyCode}}catch(${varSym.jsname}){ if(${varSym.jsname}.type === \"return-from\") _raise(${varSym.jsname}); ${isScope(handlerBodyCode) ? handlerBodyCode : value_marker +\" \" + handlerBodyCode}}`\n\t\t\t\t\t \n\t\t\t\t}\n\t\t  case withSym:\n\t\t\t\t{\n\t\t\t\t\t const [arg, ...body] = operands;\n\t\t\t\t\t // arg must be in the form (sym value)\n\t\t\t\t\t let argCode = lispCompile(arg[1]);\n\t\t\t\t\t if(isScope(argCode)){\n\t\t\t\t\t\t  argCode = argCode.replaceAll(value_marker, arg[0].jsname);\n\t\t\t\t\t }else{\n                    argCode = arg[0].jsname + \"=\" + argCode;\n\t\t\t\t\t }\n\t\t\t\t\t\t \n\t\t\t\t\t let bodyCode = lispCompileLet([], body, true)\n\t\t\t\t\t if(!isScope(bodyCode)){\n                    bodyCode = value_marker + \" \" + bodyCode;\n\t\t\t\t\t }\n\t\t\t\t\t return `{\nconst __prevv = ${arg[0].jsname}; try{ ${argCode}; ${bodyCode}; }finally{ ${arg[0].jsname} = __prevv;}}`\n\t\t\t\t\t\t  \n\n\t\t\t\t}\n\t\t\t\t// Add more cases for other operators as needed\n\t\t\t\t\n\t\t  default:\n\t\t\t\tif(operator == undefined){\n\t\t\t\t\t throw new Error(\"undefined operator in \", code)\n\t\t\t\t}\n\t\t\t\tif (macroLookup.has(operator)) {\n\t\t\t\t\t let macroFcn = macroLookup.get(operator)\n\t\t\t\t\t let newcode = null;\n\t\t\t\t\t \n\t\t\t\t\t let operands2 = operands;\n\n\t\t\t\t\t {\n\t\t\t\t\t\t  // small hack to get keywords to be their values instead\n\t\t\t\t\t\t  // of (keywordsym keywordname)\n\t\t\t\t\t\t  let anyKw = operands2.find(x => car(x) == keywordSym)\n\t\t\t\t\t\t  if(anyKw){\n\t\t\t\t\t\t\t\toperands2 = operands2.map(x => car(x) == keywordSym ? x[1] : x)\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t newcode = macroFcn(...operands2)\n\t\t\t\t\t \n\t\t\t\t\t return lispCompile(newcode)\n\t\t\t\t}\n\t\t\t\targs = operands.map(op => lispCompile(op))\n\t\t\t\tif(args.some(isScope)){\n\t\t\t\t\t let callargs = args.map((x,i) => \"arg\"+i)\n\t\t\t\t\t let argCall = args.map((x,i) => {\n\t\t\t\t\t\t  if(isScope(x)){\n\t\t\t\t\t\t\t\treturn \"var arg\" + i + \";\" + x.replaceAll(value_marker, \"arg\" + i + \"=\") + \";\";\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t  }else{\n\t\t\t\t\t\t\t\treturn \"let arg\" + i + \"=\" + x + \";\";\n\t\t\t\t\t\t  }\n\t\t\t\t\t });\n\t\t\t\t\t return `{${argCall.join(\"\")} ${value_marker} ${operator.jsname}(${callargs.join(\",\")})}`\n\t\t\t\t}\n\t\t\t\treturn `${operator.jsname}(${args})`;\n\t\t  }\n\t }finally{\n\t\t  codeStack.pop()\n\t }\n}\n\nlisp_reader = function(code) {\n\t return code;\n}\n\nfunction lispCompileAst(ast){\n    js = \"'use strict'\\n; return \"+ lispCompile(lisp_reader(ast))\n    return Function(js)\n}\n\nfunction lispCompileString(code) {\n    const [ast, next] = parser.ParseLisp(code)\n    if (next == null){\n        throw \"unable to parse code\"\n    }\n    return lispCompileAst(ast)\n}\n\nfunction evalLisp(code){\n\t let fn = lispCompileAst(code)\n\t return fn();\n}\n\nfunction countNewlinesBeforeIndex(str, index) {\n    if (index < 0 || index > str.length) {\n        throw new Error('Index out of bounds');\n    }\n\n    let newlineCount = 0;\n    for (let i = 0; i < index; i++) {\n        if (str[i] === '\\n') {\n            newlineCount++;\n        }\n    }\n\n    return newlineCount;\n}\n\n\nfunction on_lisp_error(e){\n\t console.log(e)\n}\n\nlet onErrorSym = lisp.sym(\"lisp-parser:on-error\")\n\n__webpack_require__.g[onErrorSym.jsname] = on_lisp_error;\n\neval2 = evalLisp\nloadFileAsync = null\nloadcontext = \"\"\n__ce = null\nerror = null\n\nasync function LispEvalBlock(code, file) {\n\t let len1 = code.length\n\t \n\t const originalCode = code\n\t for(;;){\n\t\t  let offset = len1 - code.length\n\t\t  parser.fileOffset = len1 - code.length\n\t\t  parser.codeBase = originalCode\n\t\t  parser.setCodeBase(originalCode)\n\t\t  const [ast, next] = parser.ParseLisp(code)\n\t\t  if (ast == parser.UnexpectedEOF){\t\n\t\t\t\tthrow new Error(`Unexpected EOF in file ${file}`)\n\t\t  }\n\t\t  \n\t\t  if (next == null){\n\t\t\t\t\n\t\t\t\treturn;\n\t\t  }\n\t\t  code = next;\n\n\t\t  try{\n\t\t\t\tlet ast2 = lisp_reader(ast);\n\t\t\t\t\n\t\t\t\tvar js = lispCompile(ast2);\n\t\t\t\tif(js.includes(\"/*DEFVAR*/\"))\n\t\t\t\t\t continue;\n\t\t\t\tif(isScope(js)){\n\t\t\t\t\t js = js.replaceAll(value_marker, \"returnValue =\");\n\t\t\t\t\t js = \"{'use strict'; var returnValue;\" + js + \"return returnValue;}\";\n\t\t\t\t}else{\n\t\t\t\t\t js = \"{'use strict'; return \" + js + \"}\";\n\t\t\t\t}\n\t\t\t\t\n\t\t  \n\t\t\t\t// there are two ways of doing this, which may be the same\n\t\t\t\t\n\t\t\t\tconst ncode = \"function __ce()\" + js;\n\t\t\t\t//console.log(ncode, file, \" line: \" + countNewlinesBeforeIndex(originalCode, offset))\n\t\t\t\tdoEval(ncode)\n\t\t  \t\tconst result = __ce();\n\t\t\t\t\n\t\t\t\tif(result != null && typeof(result) == \"object\" && result.type == \"load\"){\n\t\t\t\t\t \n\t\t\t\t\t const data = await loadFileAsync(result.value)\n\t\t\t\t\t const prevContext = loadcontext\n\t\t\t\t\t loadcontext = result.value\n\t\t\t\t\t await LispEvalBlock(data, result.value)\n\t\t\t\t\t loadcontext = prevContext\n\t\t\t\t}\n\t\t  }catch(e){\n\t\t\t\t\n\t\t\t\tif(!e._at){\n\t\t\t\t\t e._at = file + \" line: \" + (1 + countNewlinesBeforeIndex(originalCode, offset))\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthrow e\n\t\t  }\n\t }\n}\n\n// do-eval can be used to eval as single line of code.\nfunction do_eval(code){\n\t code = \"return \" + code.trim()\n\t const func = new Function(code)\n\t return func()\n}\n\njs_eval = do_eval\n\nlisp.lisp.eval = evalLisp\nlisp.lisp.LispEvalBlock = LispEvalBlock\n\nmodule.exports = {\n\t EvalLisp: evalLisp,\n\t LispEvalBlock: LispEvalBlock,\n\t lispCompile: lispCompile\n};\n\n\n//# sourceURL=webpack:///../../src/lisp.js?");

/***/ }),

/***/ "../../src/lispy_parser.js":
/*!*********************************!*\
  !*** ../../src/lispy_parser.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\ncodeBase = null\n\nfunction setCodeBase(code){\n\t codeBase = code\n}\n\nclass ParserCondition {\n    constructor(err) {\n        this.err = err;\n    }\n\t \n    toString() {\n        return \"Error parsing lisp code\";\n    }\n}\n\nclass NothingParsed2 {}\n\nconst NothingParsed = new ParserCondition();\nconst UnexpectedEOF = new ParserCondition();\n\n// Skips whitespace, including all new-lines\nfunction skipWhitespace(input) {\n\t const firstNonWhitespace = input.search(/[^\\s]/);\n\t return firstNonWhitespace === -1 ? '' : input.slice(firstNonWhitespace);\n}\n\n// skips a comment\nfunction skipComment(input) {\n\t if (input[0] !== ';') return input;\n\t const newlineIndex = input.indexOf('\\n');\n\t return newlineIndex === -1 ? '' : input.slice(newlineIndex + 1);\n}\n\nfunction skipCommentAndWhitespace(input){\n    while(true){\n        const input1 = input;\n        input = skipComment(skipWhitespace(input))\n        if(input == input1){\n\t\t\t\treturn input;\n        }\n    }\n}\n\n\n// Helper function to parse a number\nfunction parseNumber(input) {\n\t let value = \"\";\n\t let isFloat = false;\n\t let isNegative = false;\n\t let pattern = /\\d/\n\t let base = 10;\n\t if(input[0] == '#' && input[1] == 'x'){\n\t\t  pattern = /[0-9a-fA-F]/;\n\t\t  base = 16\n\t\t  input = input.slice(2)\n\t }else if(input[0] == '#' && input[1] == 'o'){\n\t\t  pattern = /[0-7]/\n\t\t  base = 8\n\t\t  input = input.slice(2)\n\t }else if(input[0] == '#' && input[1] == 'b'){\n\t\t  pattern = /[0-1]/;\n\t\t  base = 2\n\t\t  input = input.slice(2)\n\t }\n\t \n    if(input[0] == '-'){\n        isNegative = true;\n        input = input.slice(1);\n    }\n    if(input[0] == '+'){\n        input = input.slice(1)\n    }\n\t \n    while (input.length > 0 && (pattern.test(input[0]) || (!isFloat && input[0] === '.'))) {\n        value += input[0];\n        if (input[0] === '.') {\n\t\t\t\tisFloat = true;\n        }\n        input = input.slice(1);\n    }\n\t \n    if (value === \"\") {\n        return [null, null];\n    }\n\t \n    if (input.length > 0) {\n        const nextchr = input[0];\n        if (/\\s|;|\\)|\\(/.test(nextchr)) {\n\t\t\t\t\n        } else {\n\t\t\t\treturn [null, null];\n        }\n    }\n\t \n    if (isFloat) {\n        const num = parseFloat(value);\n        if (isNaN(num)) {\n\t\t\t\treturn [null, null];\n        }\n        if(isNegative){\n\t\t\t\treturn [-num, input];  \n        }\n        return [num, input];\n    }\n\t \n    const num = parseInt(value, base);\n    if (isNaN(num)) {\n        return [null, null];\n    }\n    if(isNegative){\n        return [-num, input];  \n    }\n    return [num, input];  \n}\n\nfunction parseString(input) {\n\t if (input[0] !== '\"') return [null, null];\n\n\t let value = \"\";\n\t let escaped = false;\n\t let i = 1; // Start after the opening quote\n\n\t while (i < input.length) {\n\t\t  const char = input[i++];\n\n\t\t  if (escaped) {\n\t\t\t\tvalue += char;\n\t\t\t\tescaped = false;\n\t\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (char === '\\\\') {\n\t\t\t\tescaped = true;\n\t\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (char === '\"') {\n\t\t\t\t// Closing quote found\n\t\t\t\treturn [value, input.slice(i)];\n\t\t  }\n\n\t\t  value += char;\n\t }\n\n\t return [null, null]; // Unclosed string\n}\n\n// ParseLisp0 function\nfunction ParseLisp0(input) {\n    \n    // Parsing loop\n    while (true) {\n        input = skipCommentAndWhitespace(input);\n        if (input.length === 0) {\n\t\t\t\t\n\t\t\t\treturn [NothingParsed, null];\n        }\n        \n        switch (input[0]) {\n\t\t\t\t\n        case '(':\n\t\t\t\tlet offset = codeBase.length - input.lengt\n\t\t\t\tlet input0 = input\n\t\t\t\tinput = skipCommentAndWhitespace(input.slice(1));\n\t\t\t\t\n\t\t\t\tif(input[0] == ')'){  \n\t\t\t\t\t return [[], input.slice(1)];\n\t\t\t\t}\n\t\t\t\tlet out = []\n\t\t\t\t\n\t\t\t\tfor(;;){\n\t\t\t\t\t const [result,next] = ParseLisp0(input)\n\t\t\t\t\t if(next){\n\t\t\t\t\t\t  input = next;\n\t\t\t\t\t\t  out.push(result)\n\t\t\t\t\t\t  input = skipCommentAndWhitespace(input);\n\t\t\t\t\t\t  if(input[0] == ')'){\n\t\t\t\t\t\t\t\tout.codeBase = codeBase\n\t\t\t\t\t\t\t\tout.offset = offset\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tObject.freeze(out)\n\t\t\t\t\t\t\t\treturn [out, input.slice(1)];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t  }\n\t\t\t\t\t }else{\n\t\t\t\t\t\t  return [UnexpectedEOF, null]\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tbreak;\n        case ':':\n\t\t\t\t{\n\t\t\t\t\t // Parse keyword\n\t\t\t\t\t const [r, next] = ParseLisp0(input.slice(1));\n\t\t\t\t\t return [[lisp.keyword_sym, r], next]\n\t\t\t\t}\n\n\t\t\t\tbreak;\n        case '\\'':\n\t\t\t\t{\n\t\t\t\t\t // Parse quote\n\n\t\t\t\t\t const [r, next] = ParseLisp0(input.slice(1));\n\t\t\t\t\t return [[lisp.quote_sym, r], next]\n\t\t\t\t}\n\t\t  case '`':\n\t\t\t\t{\n\t\t\t\t\t const [r, next] = ParseLisp0(input.slice(1));\n\t\t\t\t\t return [[lisp.quasiquote_sym, r], next]\n\n\t\t\t\t}\n\t\t  case ',':\n\t\t\t\t{\n\t\t\t\t\t if(input[1] == '@'){\n\t\t\t\t\t\t  const [r, next] = ParseLisp0(input.slice(2));\n\t\t\t\t\t\t  return [[lisp.quasiunquotesplice_sym, r], next]\n\t\t\t\t\t }\n\t\t\t\t\t const [r, next] = ParseLisp0(input.slice(1));\n\t\t\t\t\t return [[lisp.quasiunquote_sym, r], next]\n\n\t\t\t\t}\n        case '\"':\n\t\t\t\treturn parseString(input);\n\n\t\t\t\t\n        default:\n\t\t\t\t\n\t\t\t\tconst [num, next] = parseNumber(input);\n\t\t\t\t\n\t\t\t\tif (next) {\n\t\t\t\t\t return [num, next];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// parse symbol\n\n\t\t\t\tlet match = input.match(/^[^\\s()\\n\\t]+/);\nlet value = match ? match[0] : \"\";\n\t\t\t\tinput = match ? input.slice(value.length) : input;\n\t\t\t\tif (value === \"\"){\n\t\t\t\t\t return [null, null]\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts = lisp.sym(value);\n\t\t\t\treturn [s, input]          \n        }\n    }\n}\n\n\n\nfunction ParseLisp (codestring){\n    return ParseLisp0(codestring);\n}\n\nmodule.exports = {\n    ParseLisp: ParseLisp,\n    UnexpectedEOF: UnexpectedEOF,\n\t setCodeBase: setCodeBase\n};\n\n\n//# sourceURL=webpack:///../../src/lispy_parser.js?");

/***/ }),

/***/ "../../src/symbols.js":
/*!****************************!*\
  !*** ../../src/symbols.js ***!
  \****************************/
/***/ ((module) => {

eval("\nlisp = { symbolName: {}, symbols: [] }\nconst reserved = {\n\t\"true\": true, \"false\": true, \"null\": true, \"case\": true,\n\t \"tmp\": true, \"undefined\": true, \"new\": true, \"eval\": true, \"typeof\" : true, \"delete\": true, \"function\": true, \"continue\": true, \"break\":true, \"try\" : true, \"catch\": true, \"finally\": true, \"throw\": true, \"new\": true, \"var\": true, \"import\":true, \"module\" : true, \"await\" : true\n}\n\nconst sanitizedLookup = {}\nconst sanitizedLookupRev = {}\nconst symbolArray = []\n\nfunction register_symbol(name, sanitized){\n\tsanitizedLookup[name] = sanitized\n\tsanitizedLookupRev[sanitized] = name\n}\n\nfunction sanitizeSymbolName(name) {\n\tif (name in sanitizedLookup) {\n\t\treturn sanitizedLookup[name]\n\t}\n\n\tconst sanitized = name.replace(/[^\\.a-zA-Z0-9_]/g, '_')\n\n\tisreserved = reserved[name];\n\n\tif (sanitized == name && !isreserved)\n\t\treturn sanitized;\n\n\tif (sanitized in sanitizedLookupRev || isreserved) {\n\t\tfor (i = 0; true; i = i + 1) {\n\t\t\tconst test = `_${sanitized}_${i}`\n\t\t\tif (test in sanitizedLookupRev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregister_symbol(name, test);\n\t\t\treturn test;\n\t\t}\n\t}\n\n\tregister_symbol(name, sanitized);\n\treturn sanitized;\n\n}\n\nfunction getsym(str) {\n\treturn lisp.symbolName[str]\n}\n\nfunction sym(str, jsname) {\n\tif (!lisp.symbolName[str]) {\n\t\tif (jsname == null) {\n\t\t\tjsname = str;\n\t\t\tjsname = sanitizeSymbolName(jsname)\n\t\t}\n\n\t\tconst symbol = {\n\t\t\ttype: \"symbol\",\n\t\t\tvalue: str,\n\t\t\tjsname: jsname,\n\t\t\tindex: lisp.symbols.length\n\t\t};\n\t\tObject.freeze(symbol)\n\t\tlisp.symbolName[str] = symbol;\n\t\tlisp.symbols.push(symbol);\n\t\t\n\t}\n\treturn lisp.symbolName[str];\n}\n\nconst quote_sym = sym(\"quote\");\nconst keyword_sym = sym(\"keyword\");\nconst quasiquote_sym = sym(\"quasiquote\")\nconst quasiunquote_sym = sym(\"quasiunquote\")\nconst quasiunquotesplice_sym = sym(\"quasiunquote-splice\")\n\nmodule.exports = {\n\t sym: sym,\n\t getsym: getsym,\n\t lisp: lisp,\t\n\t quote_sym: quote_sym,\n\t keyword_sym: keyword_sym,\n\t quasiquote_sym: quasiquote_sym,\n\t quasiunquote_sym: quasiunquote_sym,\n\t quasiunquotesplice_sym: quasiunquotesplice_sym\n};\n\n\n//# sourceURL=webpack:///../../src/symbols.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../../src/foxlisp-web.js");
/******/ 	
/******/ })()
;